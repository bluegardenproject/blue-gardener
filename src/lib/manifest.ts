import fs from "fs";
import { getManifestPath, ensureProjectAgentsDir } from "./paths.js";
import { Platform } from "./platform.js";

export interface AgentEntry {
  version: string;
  installedAt: string;
}

export interface Manifest {
  _comment?: string;
  version: string;
  installedAt: string;
  /** @deprecated Use platforms instead. */
  platform?: Platform;
  platforms: Platform[];
  agents: Record<string, AgentEntry>;
}

const MANIFEST_COMMENT =
  "This file is auto-generated by blue-gardener. Do not edit manually. Run 'npx blue-gardener repair' if issues occur.";

/**
 * Read the manifest file, returns null if it doesn't exist
 */
export function readManifest(): Manifest | null {
  const manifestPath = getManifestPath();

  if (fs.existsSync(manifestPath)) {
    const content = fs.readFileSync(manifestPath, "utf-8");
    return normalizeManifest(JSON.parse(content) as Manifest);
  }

  return null;
}

/**
 * Write the manifest file
 */
export function writeManifest(manifest: Manifest): void {
  ensureProjectAgentsDir();
  const manifestPath = getManifestPath();
  const normalizedManifest = normalizeManifest(manifest);
  // Ensure comment is always present
  const manifestWithComment = {
    _comment: MANIFEST_COMMENT,
    ...normalizedManifest,
  };
  fs.writeFileSync(
    manifestPath,
    JSON.stringify(manifestWithComment, null, 2) + "\n"
  );
}

/**
 * Create a new empty manifest
 */
export function createManifest(version: string, platform?: Platform): Manifest {
  return {
    _comment: MANIFEST_COMMENT,
    version,
    installedAt: new Date().toISOString(),
    platform,
    platforms: platform ? [platform] : [],
    agents: {},
  };
}

/**
 * Normalize manifest to current schema.
 */
export function normalizeManifest(manifest: Manifest): Manifest {
  const platforms = Array.isArray(manifest.platforms)
    ? manifest.platforms
    : manifest.platform
      ? [manifest.platform]
      : [];
  const dedupedPlatforms = Array.from(new Set(platforms));

  return {
    ...manifest,
    platform: dedupedPlatforms[0],
    platforms: dedupedPlatforms,
  };
}

/**
 * Add a platform to manifest if missing.
 */
export function addPlatformToManifest(
  manifest: Manifest,
  platform: Platform
): Manifest {
  const normalized = normalizeManifest(manifest);
  if (normalized.platforms.includes(platform)) {
    return normalized;
  }

  return normalizeManifest({
    ...normalized,
    platforms: [...normalized.platforms, platform],
  });
}

/**
 * Get enabled platforms from manifest.
 */
export function getEnabledPlatforms(manifest: Manifest | null): Platform[] {
  if (!manifest) {
    return [];
  }
  return normalizeManifest(manifest).platforms;
}

/**
 * Add an agent to the manifest
 */
export function addAgentToManifest(
  manifest: Manifest,
  agentName: string,
  version: string
): Manifest {
  return {
    ...manifest,
    agents: {
      ...manifest.agents,
      [agentName]: {
        version,
        installedAt: new Date().toISOString(),
      },
    },
  };
}

/**
 * Remove an agent from the manifest
 */
export function removeAgentFromManifest(
  manifest: Manifest,
  agentName: string
): Manifest {
  const { [agentName]: _, ...remainingAgents } = manifest.agents;
  return {
    ...manifest,
    agents: remainingAgents,
  };
}

/**
 * Get list of installed agent names
 */
export function getInstalledAgentNames(): string[] {
  const manifest = readManifest();
  if (!manifest) {
    return [];
  }
  return Object.keys(manifest.agents);
}
